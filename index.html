<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Card Deck Building App</title>
  <link rel="icon" href="/favicon.svg" type="image/svg+xml">
  <style>
    :root {
      --bg1: #0b0f1a;
      --bg2: #111827;
      --surface: #0c1322;
      --surface-2: #0f172a;
      --fg: #e8ecf1;
      --muted: #a6b0bf;
      --accent: #6ee7ff;
      --chip: rgba(255,255,255,0.08);
      --border: rgba(255,255,255,0.12);
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
      color: var(--fg);
      background: linear-gradient(180deg, var(--bg1), var(--bg2));
    }

    .site-header { background: var(--surface); border-bottom: 1px solid rgba(255,255,255,0.08); }
    .site-header .wrap { display:flex; align-items:center; justify-content:space-between; gap:16px; padding:16px 0; }
    .brand { margin:0; font-size:clamp(20px,3vw,28px); letter-spacing:0.2px; }

    .wrap { width:min(1100px, 92vw); margin-inline:auto; }
    main.wrap { padding:28px 0 60px; }

    .btn { appearance:none; border:none; padding:12px 16px; border-radius:10px; font-weight:600; cursor:pointer; transition: transform 0.05s ease, background-color 0.2s ease, border-color 0.2s ease; }
    .btn:active { transform: translateY(1px) scale(0.99); }
    .btn-primary { background: var(--accent); color:#0b0f1a; }
    .btn-secondary { background: transparent; color: var(--fg); border:1px solid var(--border); }
    .btn-ghost { background: transparent; color: var(--muted); border:1px dashed var(--border); }

    .actions { display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin-bottom:22px; }
    p { color: var(--muted); margin: 0 0 16px; }

    .filters { background: var(--surface-2); border:1px solid var(--border); border-radius:14px; padding:16px; }
    .filters h2 { margin:0 0 12px; font-size:20px; }
    .filter-groups { display:grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap:16px; }
    .filter-group h3 { margin:0 0 8px; font-size:14px; color:var(--muted); font-weight:600; letter-spacing:0.2px; }

    .filter-row { display:flex; gap:8px; flex-wrap:wrap; }
    .filter-btn { background: transparent; color: var(--fg); border:1px solid var(--border); padding:8px 12px; border-radius:999px; font-weight:600; }
    .filter-btn[aria-pressed="true"], .filter-btn.is-active { background: var(--accent); color:#08101b; border-color: transparent; }

    .active-filters { margin-top:16px; display:flex; align-items:center; gap:12px; flex-wrap:wrap; }
    .chip-row { display:flex; gap:8px; flex-wrap:wrap; }
    .chip { display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px; background: var(--chip); border:1px solid var(--border); font-size:13px; }
    .chip button { border:none; background:transparent; color:var(--muted); cursor:pointer; font-weight:700; line-height:1; }

    .results { margin-top:24px; }
    .results h2 { font-size:18px; margin:16px 0 8px; }
    .results ul { padding-left: 18px; }
    .results-meta { color: var(--muted); margin: 4px 0 8px; }

    /* Card picker */
    .cards { margin: 18px 0 22px; }
    .cards h2 { font-size:18px; margin:0 0 10px; }
    .card-picker { position: relative; }
    #cardSearchInput {
      width: 100%;
      padding: 12px 14px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--surface);
      color: var(--fg);
      outline: none;
    }
    .suggestions {
      position: absolute;
      z-index: 20;
      inset-inline: 0;
      margin: 6px 0 0;
      padding: 6px 0;
      list-style: none;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 10px;
      max-height: 260px;
      overflow: auto;
      display: none;
    }
    .suggestions.show { display:block; }
    .suggestions li { padding: 8px 12px; cursor: pointer; }
    .suggestions li[aria-selected="true"], .suggestions li:hover { background: var(--surface-2); }
    .cards .chip { background: rgba(110,231,255,0.12); border-color: rgba(110,231,255,0.25); }

    .muted { color: var(--muted); }
  </style>
</head>
<body>
  <header class="site-header">
    <div class="wrap">
      <h1 class="brand">Card Deck Building App</h1>
    </div>
  </header>

  <main class="wrap" role="main">
    <section class="actions" aria-label="Page actions">
      <button class="btn btn-primary" type="button" id="findDecksBtn">Find Decks</button>
      <button class="btn btn-secondary" type="button" id="uploadCardsBtn">Upload Cards</button>
    </section>

    <!-- Cards to match -->
    <section class="cards" aria-labelledby="cards-heading">
      <h2 id="cards-heading">Cards to match (optional)</h2>
      <div class="card-picker">
        <input id="cardSearchInput" type="text" placeholder="Search cards by name…" aria-autocomplete="list" aria-controls="cardSuggestions" aria-expanded="false" />
        <ul id="cardSuggestions" class="suggestions" role="listbox" aria-label="Card suggestions"></ul>
      </div>
      <div id="selectedCards" class="chip-row" aria-live="polite" aria-label="Selected cards"></div>
      <p class="muted" id="cardHelp">Tip: add a few staples you own; we'll find decks containing as many as possible.</p>
    </section>

    <section class="filters" aria-labelledby="filter-heading">
      <h2 id="filter-heading">Filter</h2>

      <div class="filter-groups">
        <div class="filter-group" data-group="format">
          <h3>Format</h3>
          <div class="filter-row">
            <button class="filter-btn" type="button" data-filter-value="Standard" aria-pressed="false">Standard</button>
            <button class="filter-btn" type="button" data-filter-value="Modern" aria-pressed="false">Modern</button>
            <button class="filter-btn" type="button" data-filter-value="Pioneer" aria-pressed="false">Pioneer</button>
            <button class="filter-btn" type="button" data-filter-value="Commander/EDH" aria-pressed="false">Commander/EDH</button>
          </div>
        </div>

        <div class="filter-group" data-group="colors">
          <h3>Colors</h3>
          <div class="filter-row">
            <button class="filter-btn" type="button" data-filter-value="White" aria-pressed="false">White (W)</button>
            <button class="filter-btn" type="button" data-filter-value="Blue" aria-pressed="false">Blue (U)</button>
            <button class="filter-btn" type="button" data-filter-value="Black" aria-pressed="false">Black (B)</button>
            <button class="filter-btn" type="button" data-filter-value="Red" aria-pressed="false">Red (R)</button>
            <button class="filter-btn" type="button" data-filter-value="Green" aria-pressed="false">Green (G)</button>
            <button class="filter-btn" type="button" data-filter-value="Colorless" aria-pressed="false">Colorless (C)</button>
          </div>
        </div>

        <div class="filter-group" data-group="archetype">
          <h3>Archetype</h3>
          <div class="filter-row">
            <button class="filter-btn" type="button" data-filter-value="Aggro" aria-pressed="false">Aggro</button>
            <button class="filter-btn" type="button" data-filter-value="Control" aria-pressed="false">Control</button>
            <button class="filter-btn" type="button" data-filter-value="Midrange" aria-pressed="false">Midrange</button>
            <button class="filter-btn" type="button" data-filter-value="Combo" aria-pressed="false">Combo</button>
            <button class="filter-btn" type="button" data-filter-value="Tempo" aria-pressed="false">Tempo</button>
            <button class="filter-btn" type="button" data-filter-value="Ramp" aria-pressed="false">Ramp</button>
          </div>
        </div>
      </div>

      <div class="active-filters" aria-live="polite">
        <strong>Active filters:</strong>
        <div id="activeFilters" class="chip-row"></div>
        <button class="btn btn-ghost" id="clearFilters" type="button" hidden>Clear all</button>
      </div>
    </section>

    <!-- Results containers -->
    <section class="results" aria-live="polite">
      <h2>Deck results (Archidekt)</h2>
      <div id="archMeta" class="results-meta"></div>
      <ul id="archResults"></ul>

      <h2>Commander candidates (Scryfall)</h2>
      <div id="scryMeta" class="results-meta"></div>
      <ul id="scryResults"></ul>
    </section>
  </main>

<script>
  // ---------- Filter state ----------
  const filterState = new Map();
  function getSet(group){ if(!filterState.has(group)) filterState.set(group, new Set()); return filterState.get(group); }
  function hasAnyFilters(){ for (const [,set] of filterState) { if (set.size) return true; } return false; }

  function toggleFilterButtonVisual(btn, active){
    if(active){ btn.classList.add('is-active'); btn.setAttribute('aria-pressed','true'); }
    else { btn.classList.remove('is-active'); btn.setAttribute('aria-pressed','false'); }
  }

  function renderActiveFilters(){
    const container = document.getElementById('activeFilters');
    const clearBtn = document.getElementById('clearFilters');
    container.innerHTML = '';

    for (const [group, set] of filterState) {
      for (const val of set) {
        const chip = document.createElement('span');
        chip.className = 'chip';
        chip.dataset.group = group;
        chip.dataset.value = val;
        chip.innerHTML = `${group}: ${val} <button type="button" aria-label="Remove ${val} from ${group}">×</button>`;
        container.appendChild(chip);
      }
    }
    clearBtn.hidden = !hasAnyFilters();
  }

  // Core toggle that updates state only
  function toggleValue(group, value){
    const set = getSet(group);
    const willActivate = !set.has(value);
    if (willActivate) set.add(value); else set.delete(value);
    renderActiveFilters();
    return willActivate;
  }

  // ---------- Bind filter buttons directly ----------
  function bindFilterButtons(){
    document.querySelectorAll('.filter-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const groupEl = btn.closest('.filter-group');
        if (!groupEl) return;
        const group = groupEl.dataset.group;
        const value = btn.dataset.filterValue;
        const active = toggleValue(group, value);
        toggleFilterButtonVisual(btn, active);
      }, { passive: true });
    });
  }
  // Bind once on load (static buttons)
  bindFilterButtons();

  // Remove via chip (no CSS.escape dependency)
  document.getElementById('activeFilters').addEventListener('click', (e) => {
    if (e.target.tagName.toLowerCase() !== 'button') return;
    const chip = e.target.closest('.chip');
    const { group, value } = chip.dataset;
    const set = getSet(group);
    if (set.has(value)) set.delete(value);

    // Sync the corresponding button visual state by scanning buttons
    const matchBtn = Array.from(document.querySelectorAll(`.filter-group[data-group="${group}"] .filter-btn`))
      .find(b => b.dataset.filterValue === value);
    if (matchBtn) toggleFilterButtonVisual(matchBtn, false);

    renderActiveFilters();
  });

  // Clear all
  document.getElementById('clearFilters').addEventListener('click', () => {
    for (const [, set] of filterState) set.clear();
    document.querySelectorAll('.filter-btn').forEach(btn => toggleFilterButtonVisual(btn, false));
    renderActiveFilters();
  });

  // ---------- Selected cards (picker) ----------
  const selectedCards = new Set(); // store card names (exact)
  const selectedCardsEl = document.getElementById('selectedCards');
  const inputEl = document.getElementById('cardSearchInput');
  const suggEl = document.getElementById('cardSuggestions');

  function renderSelectedCards(){
    selectedCardsEl.innerHTML = '';
    [...selectedCards].forEach(name => {
      const chip = document.createElement('span');
      chip.className = 'chip';
      chip.innerHTML = `${name} <button type="button" aria-label="Remove ${name}">×</button>`;
      chip.querySelector('button').addEventListener('click', () => {
        selectedCards.delete(name);
        renderSelectedCards();
      });
      selectedCardsEl.appendChild(chip);
    });
  }

  function debounce(fn, ms=250){ let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args),ms); }; }

  const fetchAutocomplete = debounce(async (q)=>{
    if (!q || q.trim().length < 2) { suggEl.classList.remove('show'); suggEl.innerHTML=''; inputEl.setAttribute('aria-expanded','false'); return; }
    try {
      const res = await fetch(`https://api.scryfall.com/cards/autocomplete?q=${encodeURIComponent(q)}`);
      const data = await res.json();
      const names = data?.data || [];
      suggEl.innerHTML = '';
      names.slice(0, 12).forEach((name, i) => {
        const li = document.createElement('li');
        li.role = 'option';
        li.id = `sugg-${i}`;
        li.textContent = name;
        li.setAttribute('aria-selected','false');
        li.addEventListener('mousedown', (ev)=>{ // mousedown so it fires before input blur
          ev.preventDefault();
          addCard(name);
        });
        suggEl.appendChild(li);
      });
      if (names.length){ suggEl.classList.add('show'); inputEl.setAttribute('aria-expanded','true'); }
      else { suggEl.classList.remove('show'); inputEl.setAttribute('aria-expanded','false'); }
      highlightSuggestion(0);
    } catch(e){
      console.warn('Autocomplete failed', e);
      suggEl.classList.remove('show'); inputEl.setAttribute('aria-expanded','false');
    }
  }, 220);

  inputEl.addEventListener('input', (e)=> fetchAutocomplete(e.target.value));
  inputEl.addEventListener('keydown', (e)=>{
    const items = [...suggEl.querySelectorAll('li')];
    const current = items.findIndex(li => li.getAttribute('aria-selected') === 'true');
    if (e.key === 'ArrowDown'){
      e.preventDefault();
      const next = Math.min(items.length-1, current+1);
      highlightSuggestion(next);
    } else if (e.key === 'ArrowUp'){
      e.preventDefault();
      const prev = Math.max(0, current-1);
      highlightSuggestion(prev);
    } else if (e.key === 'Enter'){
      if (items.length){ e.preventDefault(); addCard(items[Math.max(0,current)].textContent); }
      else if (inputEl.value.trim().length){ e.preventDefault(); addCard(inputEl.value.trim()); }
    } else if (e.key === 'Escape'){
      suggEl.classList.remove('show'); inputEl.setAttribute('aria-expanded','false');
    }
  });
  document.addEventListener('click', (e)=>{ if(!e.target.closest('.card-picker')) { suggEl.classList.remove('show'); inputEl.setAttribute('aria-expanded','false'); } });

  function highlightSuggestion(index){
    [...suggEl.querySelectorAll('li')].forEach((li,i)=> li.setAttribute('aria-selected', i===index ? 'true':'false'));
  }

  function addCard(name){
    if (!name) return;
    if (selectedCards.size >= 100) return; // hard cap to keep payloads sane
    selectedCards.add(name);
    renderSelectedCards();
    inputEl.value = '';
    suggEl.classList.remove('show'); inputEl.setAttribute('aria-expanded','false');
  }

  // ---------- Search wiring: Archidekt + Scryfall ----------
  async function runSearch() {
    const colors = [...(filterState.get('colors') ?? [])];
    const formats = [...(filterState.get('format') ?? [])];
    const archetypes = [...(filterState.get('archetype') ?? [])];
    const cards = [...selectedCards]; // names only

    const format = formats[0] || ''; // legacy single for scryfall commander endpoint
    const formatsForArch = formats.map(f => f === 'Commander/EDH' ? 'Commander / EDH' : f);

    // Set UI state
    const btn = document.getElementById('findDecksBtn');
    btn.disabled = true; btn.textContent = 'Searching…';

    // 1) Archidekt decks
    let archJson = { decks: [] };
    try {
      const archRes = await fetch('/api/archidekt-search', {
        method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ colors, formats: formatsForArch, archetypes, cards, includeSiteTotal: true })
      });
      archJson = await archRes.json();
    } catch (e) { console.warn('Archidekt error', e); }

    const archMeta = document.getElementById('archMeta');
    const archList = document.getElementById('archResults');
    archList.innerHTML = '';

    const found = archJson.total_matching ?? archJson.count ?? (archJson.decks || []).length || 0;
    const totalSite = archJson.site_total;
    if (totalSite) {
      archMeta.textContent = `${Number(found).toLocaleString()}/${Number(totalSite).toLocaleString()} decks`;
    } else if (archJson.total_matching) {
      archMeta.textContent = `${Number(found).toLocaleString()} matching decks`;
    } else {
      archMeta.textContent = '';
    }

    (archJson.decks || []).forEach(d => {
      const li = document.createElement('li');
      const score = (typeof d.match_score === 'number') ? ` — match: ${Math.round(d.match_score*100)}%` : '';
      li.innerHTML = `<a href="${d.url}" target="_blank" rel="noopener">${d.name}</a> — ${d.owner || 'unknown'}${score}`;
      archList.appendChild(li);
    });
    if (!archList.children.length) archList.innerHTML = '<li>No results (try broadening filters or removing cards).</li>';

    // 2) Scryfall: commander/card helpers (still useful alongside deck results)
    let scryJson = { cards: [] };
    try {
      const scryRes = await fetch('/api/scryfall-search', {
        method: 'POST', headers: { 'Content-Type': 'application/json' },
        // Pass cards so your backend can bias/boost commanders that synergize with them if desired
        body: JSON.stringify({ colors, format, commanderOnly: true, order: 'edhrec', unique: 'cards', cards })
      });
      scryJson = await scryRes.json();
    } catch (e) { console.warn('Scryfall error', e); }

    const scryMeta = document.getElementById('scryMeta');
    const scryList = document.getElementById('scryResults');
    scryList.innerHTML = '';
    (scryJson.cards || []).slice(0, 20).forEach(c => {
      const li = document.createElement('li');
      li.innerHTML = `<a href="${c.scryfall_uri}" target="_blank" rel="noopener">${c.name}</a> — <small>${c.type_line || ''}</small>`;
      scryList.appendChild(li);
    });
    scryMeta.textContent = (scryJson.cards?.length) ? `${scryJson.cards.length.toLocaleString()} commanders suggested` : '';
    if (!scryList.children.length) scryList.innerHTML = '<li>No commanders found for these colors.</li>';

    // Reset UI state
    btn.disabled = false; btn.textContent = 'Find Decks';
  }

  document.getElementById('findDecksBtn').addEventListener('click', runSearch);
  document.getElementById('uploadCardsBtn').addEventListener('click', () => console.log('Upload Cards clicked (no action wired yet).'));
</script>

</body>
</html>
